{"version":3,"sources":["rewrite_clj/zip/utils.cljs"],"sourcesContent":["(ns ^:no-doc rewrite-clj.zip.utils\n  (:require [clojure.zip :as z]))\n\n;; ## Remove\n\n(defn- update-in-path\n  [[node path :as loc] k f]\n  (let [v (get path k)]\n    (if (seq v)\n      (with-meta\n        [node (assoc path k (f v) :changed? true)]\n        (meta loc))\n      loc)))\n\n(defn remove-right\n  \"Remove right sibling of the current node (if there is one).\"\n  [loc]\n  (update-in-path loc :r next))\n\n(defn remove-left\n  \"Remove left sibling of the current node (if there is one).\"\n  [loc]\n  (update-in-path loc :l pop))\n\n\n(defn remove-while\n  [zloc p?]\n  \"Remove nodes while predicate true. (depth first in reverse!) \"\n  (loop [zloc zloc]\n    (let [ploc (z/prev zloc)]\n      (if-not (and ploc (p? ploc))\n        zloc\n        (recur (z/remove zloc))))))\n\n(defn remove-right-while\n  \"Remove elements to the right of the current zipper location as long as\n   the given predicate matches.\"\n  [zloc p?]\n  (loop [zloc zloc]\n    (if-let [rloc (z/right zloc)]\n      (if (p? rloc)\n        (recur (remove-right zloc))\n        zloc)\n      zloc)))\n\n(defn remove-left-while\n  \"Remove elements to the left of the current zipper location as long as\n   the given predicate matches.\"\n  [zloc p?]\n  (loop [zloc zloc]\n    (if-let [lloc (z/left zloc)]\n      (if (p? lloc)\n        (recur (remove-left zloc))\n        zloc)\n      zloc)))\n\n;; ## Remove and Move\n\n(defn remove-and-move-left\n  \"Remove current node and move left. If current node is at the leftmost\n   location, returns `nil`.\"\n  [[_ {:keys [l] :as path} :as loc]]\n  (if (seq l)\n    (with-meta\n      [(peek l) (-> path\n                    (update-in [:l] pop)\n                    (assoc :changed? true))]\n      (meta loc))))\n\n(defn remove-and-move-right\n  \"Remove current node and move right. If current node is at the rightmost\n   location, returns `nil`.\"\n  [[_ {:keys [r] :as path} :as loc]]\n  (if (seq r)\n    (with-meta\n      [(first r) (-> path\n                     (update-in [:r] next)\n                     (assoc :changed? true))]\n      (meta loc))))\n\n\n(defn remove-and-move-up [loc]\n  (let [[node {l :l, ppath :ppath, pnodes :pnodes, rs :r, :as path}] loc]\n    (if (nil? path)\n      (throw (js/Error. \"Remove at top\"))\n      (if (pos? (count l))\n        (z/up (with-meta [(peek l)\n                    (assoc path :l (pop l) :changed? true)]\n                   (meta loc)))\n        (with-meta [(z/make-node loc (peek pnodes) rs)\n                    (and ppath (assoc ppath :changed? true))]\n                   (meta loc))))))\n\n"],"mappings":"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","names":["p__21204","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","vec__21205","rewrite-clj.zip.utils/update-in-path","cljs.core.get.cljs$core$IFn$_invoke$arity$2","path","k","cljs.core/seq","v","cljs.core/with-meta","node","cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic","f","cljs.core/meta","loc","rewrite-clj.zip.utils/remove-right","cljs.core/next","rewrite-clj.zip.utils/remove-left","cljs.core/pop","rewrite-clj.zip.utils/remove-while","zloc","clojure.zip/prev","cljs.core/not","and__4036__auto__","ploc","p?","clojure.zip/remove","rewrite-clj.zip.utils/remove-right-while","temp__5455__auto__","clojure.zip/right","rloc","rewrite-clj.zip.utils/remove-left-while","clojure.zip/left","lloc","p__21215","vec__21216","map__21219","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","rewrite-clj.zip.utils/remove-and-move-left","l","cljs.core/peek","cljs.core.update_in.cljs$core$IFn$_invoke$arity$3","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","p__21223","vec__21224","map__21227","rewrite-clj.zip.utils/remove-and-move-right","r","cljs.core/first","rewrite-clj.zip.utils/remove-and-move-up","vec__21230","map__21233","js/Error","cljs.core/count","clojure.zip/up","clojure.zip/make-node","pnodes","rs","ppath"]}