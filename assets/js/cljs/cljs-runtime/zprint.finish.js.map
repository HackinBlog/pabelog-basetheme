{"version":3,"sources":["zprint/finish.cljc"],"sourcesContent":["(ns ^:no-doc zprint.finish\n  (:require [clojure.string :as s]\n            [zprint.ansi :refer [color-str]]\n            [zprint.focus :refer [type-ssv range-ssv]]))\n\n;;\n;; # Process results from fzprint*\n;;\n\n#_(def no-style-map {:f identity, :b identity, :c identity})\n#_(def no-style-map {:f (partial conj [:reverse]), :b identity, :c identity})\n(def no-style-map\n  {:f #(if (not= %1 :none) (conj [:reverse] %1) [:reverse]),\n   :b identity,\n   :c identity})\n\n(defn within?\n  \"Is n within the closed range of low to high?\"\n  [n [low high]]\n  (and (>= n low) (<= n high)))\n\n(defn within-vec?\n  \"Is n within any of the the closed range of low to high?\"\n  [n low-high-vec]\n  (some (partial within? n) low-high-vec))\n\n(defn ground-color-to-style\n  \"Ignore any foreground/background designation, and use the\n  focus and the color to figure out a style.  Intimately \n  associated with build-styles.\n  You don't have to have a color, but you do need a ground.\n  If the ground is :c, it is used, otherwise the ground is\n  determined from the focus.  In focus gets :f, otherwise :b.\n  If you don't have a color, the style you get\n  is the same as the key for the ground you get from the\n  focus.  If you don't have a focus, you get the background.\"\n  [{:keys [style-map focus select]} s color element idx]\n  (let [output? (if select (within-vec? idx select) true)]\n    (when output?\n      ((style-map (if (= element :cursor-element)\n                    (do (println \"cursor-element:\" s) :c)\n                    #_(if (or (not focus) (within? idx focus)) :f :b)\n                    (if\n                      ; this is the right solution\n                      (and focus (within? idx focus) (not= element :indent))\n                      ;(and focus (within? idx focus))\n                      ; this is the hack solution\n                      ;(not (clojure.string/starts-with? s \"\\n\"))\n                      :f\n                      :b)))\n        (or color :none)))))\n\n(defn add-length\n  \"Given [string :style <start>] turn it into\n  [string :style <start> <length>]\"\n  [[s style start]]\n  [s style start (count s)])\n\n(defn gc-vec-to-style-vec\n  \"Take an index and a [string :color element] and produce a\n  [string :style element] with the correct elements (i.e., the\n  elements with the correct idx) having a different \n  background for focus output. The ctx is a map which\n  must have a :style-map and may have a :focus.  The\n  :focus is a two element vector of start and end elements\n  which are in focus.\"\n  [ctx idx [s keyword-color element]]\n  (let [style (ground-color-to-style ctx s keyword-color element idx)]\n    #_(prn \"s:\" s \"keyword-color:\" keyword-color \"style:\" style)\n    (when style [s (when (not= style :none) style) element])))\n\n(defn trim-vec\n  \"Take a vector of any length, and trim it to be\n  only n elements in length.\"\n  [n v]\n  (into [] (take n v)))\n\n(defn elide-indent\n  \"Take an ssv element which is presumably an indent, and do 1/2\n  of it.  If the argument is nil, do a newline with no indent.\"\n  [ssv-element]\n  (if ssv-element\n    (if (= \"\\n\" (clojure.string/replace (first ssv-element) \" \" \"\"))\n      [(apply str \"\\n\" (repeat (/ (dec (count (first ssv-element))) 1) \" \"))\n       :none]\n      [\"\\n\" :none])\n    [\"\\n\" :none]))\n\n(defn replace-nil-seq\n  \"Replace all sequences of nil in the sequence with elide\"\n  [ctx ssv-in elide]\n  (let [last-element (:last-element ctx)\n        elide [(first elide) (second last-element) (nth last-element 2)]]\n    (loop [ssv ssv-in\n           doing-nil? false\n           last-elide nil\n           out []]\n      (if (empty? ssv)\n        (if doing-nil?\n          (-> out\n              (conj\n                (gc-vec-to-style-vec ctx 0 (or last-elide (elide-indent nil))))\n              (conj (gc-vec-to-style-vec ctx 0 elide))\n              (conj (gc-vec-to-style-vec ctx 0 (:last-element ctx))))\n          out)\n        (let [this-ssv (first ssv)\n              this-elide (if (and doing-nil? (not (nil? this-ssv)))\n                           (elide-indent this-ssv)\n                           nil)]\n          (recur (next ssv)\n                 (nil? this-ssv)\n                 (if this-elide this-elide last-elide)\n                 (cond (and doing-nil? (nil? this-ssv)) out\n                       (and doing-nil? (not (nil? this-ssv)))\n                         (-> out\n                             (conj (gc-vec-to-style-vec ctx 0 this-elide))\n                             (conj (gc-vec-to-style-vec ctx 0 elide))\n                             (conj this-ssv))\n                       (nil? this-ssv) out\n                       :else (conj out this-ssv))))))))\n\n; presently unused\n(defn index-vec\n  \"Given a cvec, generate an index vector which can be input to map\n  and will make map work like map-indexed -- unless there are\n  :comment-wrap elements, in which case the :comment-wrap element\n  will have the same element idx as the previous :comment element.\"\n  [cvec]\n  (loop [remaining-cvec cvec\n         idx 0\n         out []]\n    (if-not remaining-cvec\n      out\n      (let [[_ _ element-type] (first remaining-cvec)\n            new-idx (if (= (nth (first remaining-cvec) 2) :comment-wrap)\n                      idx\n                      (inc idx))]\n        (recur (next remaining-cvec) new-idx (conj out new-idx))))))\n\n(defn cvec-to-style-vec\n  \"Take a [[string :color <anything>] \n           [string :color <anything>] ...] input.\n  The focus is a vector of [start-focus end-focus] which are the \n  inclusive values for the focus.  The end is inclusive because it \n  gets a bit dicey if it was 'beyond', since how much beyond would \n  be interesting given the amount of whitespace in the input.\n  Not clear at this point just what the counts in the focus-vec count,\n  possibly things with <anything> == :element, possibly just any\n  [string color <anything>] vector.\n  From this, build of: [[string :style] [string :style] ...], where\n  :style might be a color, like :blue or :none, or it might be a \n  java-text-pane style (which would have a color encoded in it).  This\n  is based on the :style-map in the ctx map. Note that this :style-map\n  doesn't have any relation to the :style-map in the options map.\"\n  ([ctx cvec focus-vec select-vec]\n   (let [ctx (assoc ctx :last-element (last cvec))\n         str-style-vec-w-nil (map-indexed (partial gc-vec-to-style-vec\n                                                   (assoc ctx\n                                                     :focus focus-vec\n                                                     :select select-vec))\n                                          cvec)\n         #_(map (partial gc-vec-to-style-vec\n                         (assoc ctx\n                           :focus focus-vec\n                           :select select-vec))\n             (index-vec cvec)\n             cvec)\n         count-w-nil (count str-style-vec-w-nil)\n         str-style-vec (remove nil? str-style-vec-w-nil)\n         elide-vec (when (:elide ctx) [(:elide ctx) :none])\n         str-style-vec (if (= count-w-nil (count str-style-vec))\n                         str-style-vec\n                         (if elide-vec\n                           ; Replace sequences of nil with elide-vec\n                           (replace-nil-seq ctx str-style-vec-w-nil elide-vec)\n                           str-style-vec))]\n     str-style-vec))\n  ([ctx cvec] (cvec-to-style-vec ctx cvec nil))\n  ([ctx cvec focus-vec] (cvec-to-style-vec ctx cvec focus-vec nil)))\n\n(defn compress-style\n  \"Take a [[string :style] [string :style] ...] vector and\n  build a list of: [[string :style <start> <length>] \n                    [string :style <start> <length>]...]\n  from it.  This will compress strings which have the same style.\"\n  ([str-style-vec initial-pos]\n   (loop [ss-vec str-style-vec\n          current nil\n          pos initial-pos\n          out []]\n     (let [ss (first ss-vec)]\n       (if-not ss\n         (conj out (add-length current))\n         (let [same-style? (= (second current) (second ss))]\n           (recur (next ss-vec)\n                  (if same-style?\n                    [(str (first current) (first ss)) (second current)\n                     (nth current 2)]\n                    [(first ss) (second ss) pos])\n                  (+ pos (count (first ss)))\n                  (if (or same-style? (= initial-pos pos))\n                    out\n                    (conj out (add-length current)))))))))\n  ([str-style-vec] (compress-style str-style-vec 0)))\n\n;;\n;; # Focus processing\n;;\n;; This capability, not presently maintained, is why the functions\n;; are fzprint, not zprint, in zprint.clj.\n;;\n\n(defn replace-focus-w-cursor\n  \"Take a [[string :color <anything>] \n           [string :color <anything>] ...] as input.\n  and a focus-vec and, possibly, a non-empty cursor-vec.  If\n  there is a cursor-vec, replace the focus-vec items with a cursor\n  vec and return a new focus-vec and gcw-vec as [focus-vec gcw-vec], \n  else just return with no changes\"\n  [gcw-vec [focus-start focus-end :as focus-vec] cursor-vec]\n  (if (empty? cursor-vec)\n    [focus-vec gcw-vec]\n    (let [[front back] (split-at focus-start gcw-vec)]\n      [[focus-start (+ focus-start (dec (count cursor-vec)))]\n       (concat front cursor-vec (drop (inc (- focus-end focus-start)) back))])))\n\n(defn color-style\n  \"Turn a [string :color] into an ansi colored string.\"\n  [[s color]]\n  (if (nil? color)\n    s\n    (if (coll? color) (apply color-str s color) (color-str s color))))\n\n(defn color-comp-vec\n  \"Use output from compress-style -- but just the [string :style] part,\n  which since we used identity as the color map, should be just\n  [string :color].  Produce a single string with ansi escape sequences embedded\n  in it.\"\n  [comp-vec]\n  (apply str (mapv color-style comp-vec)))\n\n\n;;\n;; # Cursor\n;;\n;; A cursor is a vector [<string> <int>], where the string\n;; is displayed and the integer is where in the string the\n;; cursor 'highlight' should be displayed\n;;\n;; Appear to be two ways to do this at present, fzprint-cursor,\n;; (which still exists, but may or may not work), and  meta-data\n;; on the sexpr which is the cursor.\n;;\n\n(defn floor\n  \"Ensure one number is above a certain value.\"\n  [f n]\n  (if (>= n f) n f))\n\n(def ^:dynamic fzprint-cursor [\"default-cursor\" 0])\n\n(defn cursor-style\n  \"Take a [<string> cursor-number] pair and produce the style-vec\n  that will display it. Allow for existing characters.\n  This is a style-vec that map-style can use, i.e.,\n  [[string <start> <length>] ...]\"\n  ([[s cursor] existing-count]\n   (prn \"cursor-style: s:\" s \",cursor:\" cursor)\n   (if cursor\n     (let [s (if (>= cursor (count s)) (str s \" \") s)\n           ;s (if (empty? s) \" \" s)\n           len (count s)\n           cursor (min (floor 0 (dec len)) cursor)]\n       (filterv #(not (empty? (first %)))\n         [[(subs s 0 cursor) :none :element]\n          [(str (get s cursor)) :none :cursor-element]\n          [(subs s (inc cursor) len) :none :element]]))\n     [[s :none :element]]))\n  ([str-cursor] (cursor-style str-cursor 0)))\n\n;;\n;; # Treat a cvec like it has lines in it\n;;\n\n(defn newline-vec\n  \"Find out how many newlines are in a string, and where they appear.\n  Returns either nil for no newlines, or a vector [<count> #{:b :m :e}]\n  for beginning, middle, or end (or all three).\"\n  [s]\n  (let [nl-split (clojure.string/split (str s \" \") #\"\\n\")\n        nl-num (dec (count nl-split))]\n    (when (not (zero? nl-num))\n      (let [where (if (empty? (first nl-split)) #{:b} #{})\n            where (if (= (last nl-split) \" \") (conj where :e) where)\n            where (if (> nl-num (count where)) (conj where :m) where)]\n        [nl-num where]))))\n\n(defn cvec-lines\n  \"Return a vector containing vectors each with the cvec elements \n  for the start and end of each line.\"\n  [cvec]\n  (loop [cvec-nl (map (comp newline-vec first) cvec)\n         idx 0\n         start 0\n         out []]\n    #_(if (zero? idx) (println \"cvec-nl:\" cvec-nl))\n    (if (empty? cvec-nl)\n      (conj out [start (dec idx)])\n      (let [[n where :as cvec-element] (first cvec-nl)]\n        #_(println \"idx:\" idx\n                   \"cvec-element:\" cvec-element\n                   \"start:\" start\n                   \"out:\" out)\n        (cond\n          (nil? cvec-element) (recur (next cvec-nl) (inc idx) start out)\n          (and (= n 1) (:b where))\n            (recur (next cvec-nl) (inc idx) idx (conj out [start (dec idx)]))\n          (and (= n 1) (:e where))\n            (recur (next cvec-nl) (inc idx) (inc idx) (conj out [start idx]))\n          (and (> n 1) (:b where) (:m where))\n            (recur\n              (next cvec-nl)\n              (inc idx)\n              idx\n              (apply conj (conj out [start (dec idx)]) (repeat n [idx idx])))\n          (:m where) (recur (next cvec-nl)\n                            (inc idx)\n                            start\n                            (apply conj out (repeat n [start idx]))))))))\n\n(defn find-line\n  \"Given a cvec index, return the line that it is in.\"\n  [lines idx]\n  (reduce #(if (within? idx %2) (reduced %1) (inc %1)) 0 lines))\n\n(defn surround-focus\n  \"Given a cvec and a focus-vec, and the number of line before and after\n  the focus, output a vector of vectors of cvec indicies that cover the \n  desired lines. [[start end] [start end] ...]\"\n  [lines-to-cvec [focus-begin focus-end] [before after]]\n  (let [line-count (count lines-to-cvec)\n        focus-begin-line (find-line lines-to-cvec focus-begin)\n        focus-end-line (find-line lines-to-cvec focus-end)\n        #_(println \"focus-begin-line:\" focus-begin-line\n                   \"focus-end-line:\" focus-end-line)\n        before-line (- focus-begin-line before)\n        before-line (if (pos? before-line) before-line 0)\n        after-line (+ focus-end-line after)\n        after-line (if (>= after-line line-count) (dec line-count) after-line)\n        surround-vec [(first (nth lines-to-cvec before-line))\n                      (second (nth lines-to-cvec after-line))]]\n    surround-vec))\n\n(defn find-range\n  \"If given a single integer, return the range from lines.  If given\n  a range of lines, return the beginning of the first line and the end\n  of the last line.\"\n  [lines line-selector]\n  (cond (number? line-selector) (nth lines line-selector)\n        (vector? line-selector) [(first (nth lines (first line-selector)))\n                                 (second (nth lines (second line-selector)))]\n        :else (throw (#?(:clj Exception.\n                         :cljs js/Error.)\n                      (str \"Line selector '\" line-selector\n                           \"' must be a number or a vector!\" line-selector)))))\n\n(defn select-lines\n  \"line-vec is a vector of individual lines, or two-vecs of\n  line ranges: [1 2 [3-5] 8 9]. Returns a vector of cvec element\n  ranges [[0 20] [45-70] ...].  lines is the return from cvec-lines,\n  which maps lines onto cvec ranges.\"\n  [lines-to-cvec line-vec]\n  (map (partial find-range lines-to-cvec) line-vec))\n\n(defn handle-lines\n  \"Take the current cvec and any focus-vec and the options map,\n  and figure out a set of cvecs to use.  Don't generate lines\n  array unless we need to.\"\n  [{{:keys [focus lines paths]} :output, :as options} cvec focus-vec]\n  (when (or lines paths (:surround focus))\n    (let [lines-to-cvec (cvec-lines cvec)\n          surround (:surround focus)\n          #_(println \"lines:\" lines \"surround:\" surround)\n          cvec-ranges (if lines (select-lines lines-to-cvec lines) [])\n          #_(println \"cvec-ranges:\" cvec-ranges)\n          cvec-ranges (if surround\n                        (conj cvec-ranges\n                              (surround-focus lines-to-cvec focus-vec surround))\n                        cvec-ranges)\n          #_(println \"cvec-ranges:\" cvec-ranges)\n          ; Turn the paths into cvec ranges\n          path-vecs (when paths (map (partial range-ssv cvec) paths))\n          #_(println \"path-vecs:\" path-vecs)\n          ; Turn cvec ranges for the bare expressions into complete lines\n          path-vecs (map #(surround-focus lines-to-cvec % [0 0]) path-vecs)\n          #_(println \"path-vecs:\" path-vecs)\n          cvec-ranges (if path-vecs (concat cvec-ranges path-vecs) cvec-ranges)\n          #_(def cvr cvec-ranges)]\n      (if (empty? cvec-ranges) nil cvec-ranges))))"],"mappings":"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","names":["zprint.finish/no-style-map","p1__21533#","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","cljs.core/identity","p__21539","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","vec__21542","zprint.finish/within?","n","low","high","zprint.finish/within-vec?","cljs.core/some","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","low-high-vec","p__21547","map__21549","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","zprint.finish/ground-color-to-style","select","idx","output?","fexpr__21565","G__21566","G__21567","style-map","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","element","cljs.core.println.cljs$core$IFn$_invoke$arity$variadic","s","and__4036__auto__","focus","or__4047__auto__","color","p__21576","vec__21577","zprint.finish/add-length","style","start","cljs.core/count","p__21580","vec__21581","zprint.finish/gc-vec-to-style-vec","ctx","keyword-color","zprint.finish/trim-vec","cljs.core.into.cljs$core$IFn$_invoke$arity$2","cljs.core.take.cljs$core$IFn$_invoke$arity$2","v","zprint.finish/elide-indent","ssv-element","clojure.string/replace","cljs.core/first","cljs.core.apply.cljs$core$IFn$_invoke$arity$3","cljs.core/str","cljs.core.repeat.cljs$core$IFn$_invoke$arity$2","zprint.finish/replace-nil-seq","elide","cljs.core/second","last-element","cljs.core.nth.cljs$core$IFn$_invoke$arity$2","ssv-in","cljs.core/empty?","ssv","doing-nil?","out","last-elide","this-ssv","cljs.core/next","this-elide","zprint.finish/index-vec","cvec","cljs.core/not","remaining-cvec","vec__21591","new-idx","G__21596","zprint.finish/cvec-to-style-vec","js/Error","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","cljs.core/last","cljs.core.map_indexed.cljs$core$IFn$_invoke$arity$2","cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic","focus-vec","select-vec","str-style-vec-w-nil","cljs.core.remove.cljs$core$IFn$_invoke$arity$2","cljs.core/nil?","count-w-nil","str-style-vec","elide-vec","zprint.finish.cvec_to_style_vec.cljs$core$IFn$_invoke$arity$3","zprint.finish.cvec_to_style_vec.cljs$core$IFn$_invoke$arity$4","G__21599","zprint.finish/compress-style","initial-pos","ss-vec","ss","current","same-style?","pos","zprint.finish.compress_style.cljs$core$IFn$_invoke$arity$2","p__21605","vec__21606","zprint.finish/replace-focus-w-cursor","cursor-vec","gcw-vec","vec__21609","cljs.core/split-at","focus-start","cljs.core.concat.cljs$core$IFn$_invoke$arity$variadic","front","cljs.core.drop.cljs$core$IFn$_invoke$arity$2","focus-end","back","p__21622","vec__21623","zprint.finish/color-style","cljs.core/coll?","zprint.ansi/color-str","zprint.ansi.color_str.cljs$core$IFn$_invoke$arity$variadic","zprint.finish/color-comp-vec","cljs.core.mapv.cljs$core$IFn$_invoke$arity$2","comp-vec","zprint.finish/floor","f","zprint.finish/fzprint-cursor","G__21628","zprint.finish/cursor-style","p__21629","vec__21630","cljs.core.prn.cljs$core$IFn$_invoke$arity$variadic","cursor","x__4138__auto__","y__4139__auto__","len","cljs.core/filterv","p1__21626#","cljs.core.subs.cljs$core$IFn$_invoke$arity$3","zprint.finish.cursor_style.cljs$core$IFn$_invoke$arity$2","str-cursor","zprint.finish/newline-vec","clojure.string.split.cljs$core$IFn$_invoke$arity$2","nl-split","nl-num","where","zprint.finish/cvec-lines","cljs.core.map.cljs$core$IFn$_invoke$arity$2","cljs.core.comp.cljs$core$IFn$_invoke$arity$2","cvec-nl","vec__21675","cvec-element","cljs.core/conj","zprint.finish/find-line","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","p2__21678#","p1__21679#","cljs.core/reduced","lines","p__21680","vec__21682","p__21681","vec__21685","zprint.finish/surround-focus","lines-to-cvec","focus-begin","focus-begin-line","before","before-line","focus-end-line","after","after-line","line-count","surround-vec","zprint.finish/find-range","line-selector","cljs.core/vector?","zprint.finish/select-lines","line-vec","p__21697","map__21698","map__21699","zprint.finish/handle-lines","paths","surround","cvec-ranges","zprint.focus/range-ssv","p1__21695#","path-vecs","cljs.core.concat.cljs$core$IFn$_invoke$arity$2"]}