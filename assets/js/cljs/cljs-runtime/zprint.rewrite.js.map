{"version":3,"sources":["zprint/rewrite.cljc"],"sourcesContent":["(ns zprint.rewrite\n  (:require\n    clojure.string\n    [zprint.zutil :as zu :refer [string tag zreplace sexpr edn*]]\n    [rewrite-clj.parser :as p]\n    [rewrite-clj.node :as n]\n    [rewrite-clj.zip :as z]\n    #?@(:cljs [[rewrite-clj.zip.base :as zb] [rewrite-clj.zip.whitespace :as zw]\n               [rewrite-clj.zip.move :as zm] [rewrite-clj.zip.removez :as zr]\n               [rewrite-clj.zip.editz :as ze] clojure.zip])))\n\n;;\n;; No prewalk in rewrite-cljs, so we'll do it ourselves here\n;; for both environments, so that we can lean on the clj testing\n;; for cljs.\n;;\n\n(defn- prewalk-subtree\n  [p? f zloc]\n  (loop [loc zloc]\n    (if (z/end? loc)\n      loc\n      (if (p? loc)\n        (if-let [n (f loc)]\n          (recur (z/next n))\n          (recur (z/next loc)))\n        (recur (z/next loc))))))\n\n(defn prewalk\n  [zloc p? f]\n  (z/replace zloc\n             (z/root (prewalk-subtree p?\n                                      f\n                                      ; Make a zipper whose root is zloc\n                                      (some-> zloc\n                                              z/node\n                                              edn*)))))\n\n\n;;\n;; # Routines to modify zippers inside of zprint\n;;\n\n(defn get-sortable\n  \"Given a zloc, get something out of it that is sortable.\"\n  [zloc]\n  (loop [nloc zloc]\n    (if (= (z/tag nloc) :token)\n      (str (z/string nloc)\n           (let [next-element (z/right nloc)]\n             (if (= (z/tag next-element) :token) (z/string next-element) \"\")))\n      (recur (z/down nloc)))))\n\n(defn sort-val\n  \"Sort the everything in the vector to the right of zloc.\"\n  [zloc]\n  (let [dep-val zloc\n        dep-seq (loop [nloc zloc\n                       out []]\n                  (if nloc (recur (z/right nloc) (conj out nloc)) out))\n        #_(println \"sort-val: count:\" (count dep-seq))\n        dep-count (count dep-seq)\n        sorted-seq (sort-by get-sortable dep-seq)\n        #_(println \"sort-val: dep-seq:\" (mapv get-sortable dep-seq))\n        #_(println \"sort-val: sorted-seq:\" (mapv get-sortable sorted-seq))]\n    (loop [nloc zloc\n           new-loc sorted-seq\n           last-loc nil]\n      #_(println \"sort-val: loop: before:\" (z/string nloc))\n      #_(when nloc (println \"sort-val: loop: n/tag:\" (n/tag (z/node nloc))))\n      #_(when new-loc\n          (println \"sort-val: loop: after:\" (n/string (z/node (first new-loc))))\n          (println \"sort-val: loop: n/tag:\" (n/tag (z/node (first new-loc)))))\n      (if new-loc\n        (let [new-z (first new-loc)\n              ; rewrite-cljs doesn't handle z/node for :uneval\n              ; so we will get an :uneval node a different way\n              new-node (if (= (z/tag new-z) :uneval)\n                         (p/parse-string (z/string new-z))\n                         (z/node new-z))\n              ; use clojure.zip for cljs, since the z/replace has\n              ; a built-in coerce, which doesn't work for an :uneval\n              replaced-loc #?(:clj (z/replace nloc new-node)\n                              :cljs (clojure.zip/replace nloc new-node))]\n          #_(println \"sort-val: loop: replaced-loc n/tag:\"\n                     (n/tag (z/node replaced-loc)))\n          (recur (z/right replaced-loc) (next new-loc) replaced-loc))\n        (z/up last-loc)))))\n\n(defn sort-down\n  \"Do a down and a sort-val\"\n  [zloc]\n  (sort-val (z/down (z/right zloc))))\n\n(defn sort-dependencies\n  \"Reorder the dependencies in a project.clj file.\"\n  [caller options zloc]\n  (let [new-dep (prewalk zloc\n                         #(and (= (z/tag %1) :token)\n                               (= (z/sexpr %1) :dependencies))\n                         sort-down)]\n    new-dep))\n"],"mappings":"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","names":["zprint.rewrite/prewalk-subtree","zloc","rewrite-clj.zip/end?","loc","p?","temp__5455__auto__","f","rewrite-clj.zip/next","n","zprint.rewrite/prewalk","G__21446","G__21447","rewrite-clj.zip/replace","G__21448","rewrite-clj.zip/root","G__21449","rewrite-clj.zip/node","zprint.zutil/edn*","zprint.rewrite/get-sortable","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","rewrite-clj.zip/tag","nloc","rewrite-clj.zip/string","rewrite-clj.zip/right","next-element","rewrite-clj.zip/down","zprint.rewrite/sort-val","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","out","cljs.core/count","dep-seq","cljs.core.sort_by.cljs$core$IFn$_invoke$arity$2","sorted-seq","new-loc","cljs.core/first","new-z","rewrite-clj.parser/parse-string","clojure.zip/replace","new-node","replaced-loc","cljs.core/next","rewrite-clj.zip/up","last-loc","zprint.rewrite/sort-down","G__21452","zprint.rewrite/sort-dependencies","p1__21453#","rewrite-clj.zip/sexpr","new-dep"]}