{"version":3,"sources":["rewrite_clj/zip/editz.cljs"],"sourcesContent":["(ns rewrite-clj.zip.editz\n  (:refer-clojure :exclude [replace])\n  (:require [rewrite-clj.zip.base :as base]\n            [rewrite-clj.zip.move :as m]\n            [rewrite-clj.zip.removez :as r]\n            [rewrite-clj.zip.utils :as u]\n            [rewrite-clj.zip.whitespace :as ws]\n            [rewrite-clj.node :as n]\n            [clojure.zip :as z]))\n\n;; ## In-Place Modification\n\n(defn replace\n  \"Replace the node at the given location with one representing\n   the given value. (The value will be coerced to a node if\n   possible.)\"\n  [zloc value]\n  (z/replace zloc (n/coerce value)))\n\n(defn- edit-node\n  \"Create s-expression from node, apply the function and create\n   node from the result.\"\n  [node f]\n  (-> (n/sexpr node)\n      (f)\n      (n/coerce)))\n\n(defn edit\n  \"Apply the given function to the s-expression at the given\n   location, using its result to replace the node there. (The\n   result will be coerced to a node if possible.)\"\n  [zloc f & args]\n  (z/edit zloc edit-node #(apply f % args)))\n\n;; ## Splice\n\n\n\n(defn splice\n  \"Splice the given node, i.e. merge its children into the current one\n   (akin to Clojure's `unquote-splicing` macro: `~@...`).\n   - if the node is not one that can have children, no modification will\n     be performed.\n   - if the node has no or only whitespace children, it will be removed.\n   - otherwise, splicing will be performed, moving the zipper to the first\n     non-whitespace child afterwards.\n   \"\n  [zloc]\n  (if (z/branch? zloc)\n    (if-let [children (->> (z/children zloc)\n                           (drop-while n/whitespace?)\n                           (reverse)\n                           (drop-while n/whitespace?)\n                           (seq))]\n      (let [loc (->> (reduce z/insert-right zloc children)\n                     (u/remove-and-move-right))]\n        (or (ws/skip-whitespace loc) loc))\n      (r/remove zloc))\n    zloc))\n\n;; ## Prefix/Suffix\n\n(defn- edit-token\n  [zloc str-fn]\n  (let [e (base/sexpr zloc)\n        e' (cond (string? e) (str-fn e)\n                 (keyword? e) (keyword (namespace e) (str-fn (name e)))\n                 (symbol? e) (symbol (namespace e) (str-fn (name e))))]\n    (z/replace zloc (n/token-node e'))))\n\n(defn- edit-multi-line\n  [zloc line-fn]\n  (let [n (-> (z/node zloc)\n              (update-in [:lines] (comp line-fn vec)))]\n    (z/replace zloc n)))\n\n(defn prefix\n  [zloc s]\n  (case (base/tag zloc)\n    :token      (edit-token zloc #(str s %))\n    :multi-line (->> (fn [lines]\n                       (if (empty? lines)\n                         [s]\n                         (update-in lines [0] #(str s %))))\n                     (edit-multi-line zloc ))))\n\n(defn suffix\n  [zloc s]\n  (case (base/tag zloc)\n    :token      (edit-token zloc #(str % s))\n    :multi-line (->> (fn [lines]\n                       (if (empty? lines)\n                         [s]\n                         (concat (butlast lines) (str (last lines) s))))\n                     (edit-multi-line zloc))))\n"],"mappings":"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","names":["rewrite-clj.zip.editz/replace","clojure.zip/replace","zloc","rewrite-clj.node/coerce","value","rewrite-clj.zip.editz/edit-node","rewrite-clj.node/sexpr","node","G__21264","f","G__21263","i__4642__auto__","len__4641__auto__","args__4647__auto__","cljs.core/IndexedSeq","rewrite-clj.zip.editz/edit","argseq__4648__auto__","cljs.core/first","seq21266","cljs.core/next","self__4628__auto__","G__21267","G__21268","clojure.zip.edit.cljs$core$IFn$_invoke$arity$variadic","p1__21265#","cljs.core.apply.cljs$core$IFn$_invoke$arity$3","args","rewrite-clj.zip.editz/splice","clojure.zip/branch?","temp__5455__auto__","clojure.zip/children","cljs.core.drop_while.cljs$core$IFn$_invoke$arity$2","rewrite-clj.node/whitespace?","cljs.core/reverse","cljs.core/seq","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","clojure.zip/insert-right","children","rewrite-clj.zip.utils/remove-and-move-right","or__4047__auto__","rewrite_clj.zip.whitespace.skip_whitespace.cljs$core$IFn$_invoke$arity$1","loc","rewrite-clj.zip.removez/remove","rewrite-clj.zip.editz/edit-token","rewrite-clj.zip.base/sexpr","e","str-fn","cljs.core/Keyword","cljs.core.keyword.cljs$core$IFn$_invoke$arity$2","cljs.core/namespace","G__21271","cljs.core/name","cljs.core/Symbol","cljs.core.symbol.cljs$core$IFn$_invoke$arity$2","G__21272","rewrite-clj.node/token-node","e'","rewrite-clj.zip.editz/edit-multi-line","clojure.zip/node","cljs.core.update_in.cljs$core$IFn$_invoke$arity$3","cljs.core.comp.cljs$core$IFn$_invoke$arity$2","line-fn","cljs.core/vec","n","rewrite-clj.zip.editz/prefix","G__21275","js/Error","rewrite-clj.zip.base/tag","p1__21273#","s","cljs.core/empty?","lines","p1__21274#","rewrite-clj.zip.editz/suffix","G__21277","p1__21276#","cljs.core.concat.cljs$core$IFn$_invoke$arity$2","cljs.core/butlast","cljs.core/last"]}